# 课时1：课程全景图

![image-20230203190938179](.\images\image-20230203190938179.png)

# 课时2：`Jupyter` 的优点

## 整合所有的资源

在真正的软件开发中，上下文切换占用了大量的时间。什么意思呢？举个例子你就很好理解了，比如你需要切换窗口去看一些文档，再切换窗口去用另一个工具画图等等。这些都是影响生产效率的因素。

正如我前面提到的，`Jupyter` 通过把所有和软件编写有关的资源全部放在一个地方，解决了这个问题。当你打开一个 `Jupyter Notebook` 时，就已经可以看到相应的文档、图表、视频和相应的代码。这样，你就不需要切换窗口去找资料，只要看一个文件，就可以获得项目的所有信息。

## 交互性编程体验

在机器学习和数学统计领域，Python 编程的实验性特别强，经常出现的情况是，一小块代码需要重写 100 遍，比如为了尝试 100 种不同的方法，但别的代码都不想动。这一点和传统的 Python 开发有很大不同。如果是在传统的 Python 开发流程中，每一次实验都要把所有代码重新跑一遍，会花费开发者很多时间。特别是在像 Facebook 这样千万行级别的代码库里，即使整个公司的底层架构已经足够优化，真要重新跑一遍，也需要几分钟的时间。

而 `Jupyter Notebook` 引进了 Cell 的概念，每次实验可以只跑一小个 Cell 里的代码；并且，所见即所得，在代码下面立刻就可以看到结果。这样强的互动性，让 Python 研究员可以专注于问题本身，不被繁杂的工具链所累，不用在命令行直接切换，所有科研工作都能在 `Jupyter` 上完成。

## 零成本重现结果

同样在机器学习和数学统计领域，Python 的使用是非常短平快的。常见的场景是，我在论文里看到别人的方法效果很好，可是当我去重现时，却发现需要 pip 重新安装一堆依赖软件。这些准备工作可能会消耗你 80% 的时间，却并不是真正的生产力。

`Jupyter Notebook` 如何解决这个问题呢？

其实最初的 `Jupyter Notebook` 也是挺麻烦的，需要你先在本机上安装 `IPython` 引擎及其各种依赖软件。不过现在的技术趋势，则是彻底云端化了，例如 `Jupyter` 官方的 Binder 平台（介绍文档：https://mybinder.readthedocs.io/en/latest/index.html）和 Google 提供的 `Google Colab` 环境（介绍：https://colab.research.google.com/notebooks/welcome.ipynb）。它们让 `Jupyter Notebook` 变得和石墨文档、Google Doc 在线文档一样，在浏览器点开链接就能运行。

所以，现在当你用 Binder 打开一份 GitHub 上的 `Jupyter Notebook` 时，你不需要安装任何软件，直接在浏览器打开一份代码，就能在云端运行。

# 课时3：列表与元组

## 概念

列表和元组都是一个可以放置**任意数据类型**的**有序集合**，和其它语言不同，集合里的数据类型不需要一致。

## 区别

- **列表是动态的**，长度大小不固定，可以随意地增加、删减或者改变元素（mutable）。
- **而元组是静态的**，长度大小固定，无法增加删减或者改变（immutable）。如果想要做任何改变，只能重新开辟一块内存。

```python
tup = (1, 2, 3, 4)
new_tup = tup + (5, ) # 创建新的元组 new_tup，并依次填充原元组的值
# (1, 2, 3, 4, 5)
 
l = [1, 2, 3, 4]
l.append(5) # 添加元素 5 到原列表的末尾
# [1, 2, 3, 4, 5]
```

## 特性

- 都支持负数索引

- 都支持切片操作，左闭右开，从零开始

- 可以随意嵌套

- 可以相互转化

  ```python
  list((1, 2, 3))
  tuple([1, 2, 3])
  ```

## 常用函数

```python
l = [3, 2, 3, 7, 8, 1]
l.count(3) 
2
l.index(7)
3
l.reverse() # 原地进行，元组没有该内置函数
l
[1, 8, 7, 3, 2, 3]
l.sort() # 原地进行，元组没有该内置函数
l
[1, 2, 3, 3, 7, 8]

tup = (3, 2, 3, 7, 8, 1)
tup.count(3)
2
tup.index(7)
3
list(reversed(tup)) # 返回新元组
[1, 8, 7, 3, 2, 3]
sorted(tup) # 返回新元组
[1, 2, 3, 3, 7, 8]
```

## 存储方式差异

元组和列表底层都是array，但比较两者占用空间会发现列表稍大一些：

1. 列表是动态的，所以它需要额外空间存储指针来指向对应的元素
2. 列表是可变的，所以它需要额外空间存储已经分配的长度大小，这样才可以实时追踪列表空间的使用情况，当空间不足时，及时分配额外空间。为了减小每次增加/删除操作的空间分配开销，Python采用了over-allocating的机制，每次都会额外多分配一些。

## 性能比较

整体：元组要比列表更加轻量级一些，所以总体上来说，元组的性能速度要略优于列表。且元组在不被使用并且空间不大时，内存不会被回收，可以加快程序的运行速度。

初始化：元组的初始化速度比列表要快5倍左右

索引操作：两者差不多

增删改元素：列表>元组

# 课时4：字典和集合

## 概念

字典：是一系列由键（key）和值（value）配对组成的元素的集合，在3.7后确定为有序的，相比于列表和元组，字典在增删查方面性能更优；

集合：和字典基本相同，唯一区别就是集合没有键值的配对，所有元素是无序的、唯一的。

## 共同点

- 无论是键还是值，都可以是混合类型
- 本质上是一个哈希表

## 基本操作

```python
# 创建
d1 = {'name': 'jason', 'age': 20, 'gender': 'male'}
d2 = dict({'name': 'jason', 'age': 20, 'gender': 'male'})
d3 = dict([('name', 'jason'), ('age', 20), ('gender', 'male')])
d4 = dict(name='jason', age=20, gender='male') 
d1 == d2 == d3 ==d4
True
 
s1 = {1, 2, 3}
s2 = set([1, 2, 3])
s1 == s2
True

# 访问
# 字典直接索引键，集合不能索引
d1['name']
'jason'
d1.get('name')
'jason'
d1.get('location', 'null')
'null'

# 判断是否在字典或集合内
1 in s1
True
10 in s1
False

'name' in d1
True
'location' in d1
False

# 增加、删除、更新等操作
d1['key'] = 'value' # key存在即为更新，不存在即为增加
d1.pop('key') # 没有key时删除的是最后一个，所以集合一般不用这个方法

s1.add(4)
s1.remove(4)

# 排序
d = {'b': 1, 'a': 2, 'c': 10}
# 根据字典键的升序排序
d_sorted_by_key = sorted(d.items(), key=lambda x: x[0])
# 根据字典值的升序排序
d_sorted_by_value = sorted(d.items(), key=lambda x: x[1])
d_sorted_by_key
[('a', 2), ('b', 1), ('c', 10)]
d_sorted_by_value
[('b', 1), ('a', 2), ('c', 10)]

s = {3, 4, 2, 1}
sorted(s) # 对集合的元素进行升序排序
[1, 2, 3, 4]
```

## 字典和集合的工作原理

### 存储结构

字典和集合的内部结构都是一张哈希表。

- 对于字典而言，这张表存储了哈希值（hash）、键和值这 3 个元素。
- 而对集合来说，区别就是哈希表内没有键和值的配对，只有单一的元素了。

老版存储方式：随着哈希表的扩张，他会变得越来越稀疏

<img src=".\images\image-20230203213822528.png" alt="image-20230203213822528" style="zoom: 80%;" />

<img src=".\images\image-20230203214019401.png" alt="image-20230203214019401" style="zoom:80%;" />



新版存储方式：空间利用率得到很大的提高

<img src=".\images\image-20230203213921311.png" alt="image-20230203213921311" style="zoom:80%;" />

<img src=".\images\image-20230203214105913.png" alt="image-20230203214105913" style="zoom:80%;" />

### 插入操作

每次向字典或集合插入一个元素时，Python 会首先计算键的哈希值（hash(key)），再和 mask = PyDicMinSize - 1 做与操作，计算这个元素应该插入哈希表的位置 index = hash(key) & mask。如果哈希表中此位置是空的，那么这个元素就会被插入其中。

而如果此位置已被占用，Python 便会比较两个元素的哈希值和键是否相等。

- 若两者都相等，则表明这个元素已经存在，如果值不同，则更新值。
- 若两者中有一个不相等，这种情况我们通常称为哈希冲突（hash collision），意思是两个元素的键不相等，但是哈希值相等。这种情况下，Python 便会继续寻找表中空余的位置，直到找到位置为止。

值得一提的是，通常来说，遇到这种情况，最简单的方式是线性寻找，即从这个位置开始，挨个往后寻找空位。当然，Python 内部对此进行了优化，让这个步骤更加高效。

### 查找操作

和前面的插入操作类似，Python 会根据哈希值，找到其应该处于的位置；然后，比较哈希表这个位置中元素的哈希值和键，与需要查找的元素是否相等。如果相等，则直接返回；如果不等，则继续查找，直到找到空位或者抛出异常为止。

### 删除操作

对于删除操作，Python 会暂时对这个位置的元素，赋于一个特殊的值，等到重新调整哈希表的大小时，再将其删除。

### 哈希表大小调整

哈希冲突的发生，往往会降低字典和集合操作的速度。因此，为了保证其高效性，字典和集合内的哈希表，通常会保证其至少留有 1/3 的剩余空间。随着元素的不停插入，当剩余空间小于 1/3 时，Python 会重新获取更大的内存空间，扩充哈希表。不过，这种情况下，表内所有的元素位置都会被重新排放。